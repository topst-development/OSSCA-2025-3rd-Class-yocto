

1week 디렉토리의 이건fetch의예제입니다.txt 내용을 보면 fetch와 pull의 차이점이란 문구가 있습니다.
또한 2week 디렉토리의 [브랜치.md](http://xn--lj2b25jw9o.md/) 내용을 git을 활용한 컨트리뷰션에서 제일많이 고민해야하는 부분은 branch이고, Agile의 성격에 가장 잘 맞는 methodology 문구가 있습니다.

멘토님의 과제 의도를 종합해보면, 리모트 레포지토리를 활용한 SW 개발 협업에서 반드시 이해해야 할  **트래킹 브랜치(tracking branch)**의 개념을 설명하고, 이를 통해 fetch와 pull의 차이점을 비교하는 것이라고 생각했습니다.

또한, 협업 과정에서  목적에 맞게 branch를 전략적으로 사용해야 하며,  Agile 전략을 효과적으로 실현하기 위해 사용되는 GitHub flow에 대해 (1) 메인 브랜치, (2) 기능 브랜치들의 역할과 특징을 설명하는 과제라고 생각했습니다. Git Flow와 GitHub Flow에 대해 비교하며 각 브랜치들의 역할과 특징을 공부할 수 있는 기회였습니다.

# 1. 트래킹 브랜치란

### Git 공식 문서 <3.5 Git 브랜치 – 리모트 브랜치>에 따르면, 

<aside>
💡

리모트 트래킹 브랜치(remote-tracking branch)는 리모트 브랜치를 추적하는 일종의 참조(reference)이자 브랜치다. 로컬에 존재하지만 사용자가 임의로 이동하거나 수정할 수는 없으며, 리모트 서버에 연결할 때마다 리모트 브랜치의 최신 상태에 맞게 자동으로 갱신된다. 

쉽게 말해, 리모트 저장소에 마지막으로 연결했을 때 해당 브랜치가 가리키던 커밋을 알려주는 **북마크** 같은 개념이다.

</aside>

---

이에 대해 트래킹 브랜치에 대해 공부한 내용을 정리하면 다음과 같습니다.

- 로컬 레포지토리에서 리모트 레포지토리의 브랜치에 대해 **fetch**나 **push**를 수행하면 로컬에는 대응되는 **트래킹 브랜치**가 생성된다.
- 트래킹 브랜치는 로컬의 일반 브랜치와는 달리 두 가지 제약이 있다.
    1. `checkout` 할 수 없다 → 즉, 해당 브랜치로 직접 이동해 작업할 수 없다.
    2. 커밋을 만들 수 없다 → 따라서 작업 내역을 추가할 수도 없다.

즉, **트래킹 브랜치의 역할은 리모트 저장소 브랜치의 상태를 알려주는 것**에 국한된다. 사용자가 직접 건드릴 수 없고, `checkout`이나 커밋도 불가능하다.

또한, 리모트 저장소에서 브랜치를 **fetch** 하면, 로컬 레포지토리에서는 해당 트래킹 브랜치가 **덮어쓰여 갱신**된다.

# 2. 트래킹 브랜치에 따른 fetch와 pull의 차이점

즉 `fetch`만 수행해서는, 동료가 리모트 레포지토리에 올린 새로운 커밋 내용을 제 작업 공간으로 가져와 그 위에 추가로 작업할 수 없습니다.

이를 해결하기 위해서는, `fetch` 이후에 반드시 업데이트된 원격 추적 브랜치(`origin/main`)의 내용을 제 로컬 브랜치(`main`)로 **병합(merge)하는 추가적인 단계**를 수행해야 합니다.

이것이 저는 fetch와 pull의 차이점이라고 생각했습니다.

## 2.1 fetch란

`git fetch`는 리모트 레포지토리의 브랜치 변경사항을 로컬 레포지토리로 업데이트하는 명령어입니다.

- 리모트 저장소의 변경 내용을 로컬에 다운로드하지만, 현재 작업 중인 브랜치에는 아무런 영향도 주지 않는다.(머지 되지 않습니다.)
- 가져온 내용은 로컬의 **트래킹 브랜치**에 반영됩니다.
- 따라서 `fetch` 이후에는 `merge`나 `rebase`를 통해서만 로컬 브랜치에 실제 변경 사항을 반영할 수 있다.

즉, `fetch`는 업데이트된 리모트 상태를 확인하고 반영 여부를 직접 선택할 수 있게 해주는 동작입니다.

## 2.2. pull이란

`git pull`은 사실상 `git fetch` + `git merge`  두 개의 동작이 동시에 수행되는 명령어입니다.

- 먼저 `fetch`처럼 리모트 저장소에서 최신 정보를 가져온다.
- 이어서 자동으로 **현재 체크아웃된 브랜치와 병합**(merge 또는 rebase 옵션에 따라 다름)을 수행한다.
- 따라서 한 번의 명령으로 원격 변경 사항을 바로 로컬 브랜치에 반영할 수 있다.

하지만 자동 병합이 이루어지기 때문에, 충돌(conflict)이 발생할 수 있으며, 이 경우 직접 해결해야 한다.

# 3. Agile 전략을 활용하기 위한 GitHub Flow

## 3.1 Git Flow와 GitHub Flow의 전략 차이

### 3.1.1 Git Flow

![Image](https://github.com/user-attachments/assets/a7397e87-e865-4c43-8476-4e36f41494f0)

기능을 개발할 때는 **feature 브랜치**를 생성하고 `checkout`을 통해 해당 브랜치로 이동해 작업합니다.

기능 개발이 완료되면 **develop 브랜치**에 `merge`합니다.

현재 단계에서는 develop 브랜치를 `main` 브랜치처럼 **기준 브랜치**로 생각할 수 있습니다.

만약 develop 브랜치에서 필요한 작업이 모두 끝났다면, 그 시점에서 **release 브랜치**를 분기합니다..

Release 브랜치에서 문제가 발생하면 해당 브랜치에서 수정한 뒤 **develop 브랜치**로 다시 `merge`합니다.

Release 브랜치의 코드가 배포까지 정상적으로 완료되면, 최종 코드를 develop 브랜치와 master 브랜치 모두에 `merge`합니다.

 **hotfix 브랜치**는 이미 운영 중인 소프트웨어에서 긴급하게 수정해야 하는 심각한 버그, 보안 취약점, 기능적 결함 등을 해결할 때 사용합니다.

Hotfix는 정기 업데이트나 다음 버전 출시를 기다리지 않고 **신속하게 적용**되는 긴급 수정 작업을 의미합니다.

Hotfix 브랜치에서 문제가 해결되면 develop 브랜치와 master 브랜치 순으로 `merge`하여 반영합니다.

---


### 3.1.2 GitHub Flow

![Image](https://github.com/user-attachments/assets/3add3e59-ab0e-4ee7-837c-1f331f19d4d2)

Github Flow는 **짧은 개발 주기, 빠른 배포, 사용자 중심의 피드백 반영**이라는 애자일 개발의 핵심 가치와 잘 맞아떨어집니다.

기능 단위로 브랜치를 생성하고 빠르게 병합할 수 있어 배포가 신속히 이루어집니다. 이는 곧, 사용자의 피드백을 곧바로 제품에 반영해 지속적인 개선(CI/CD)을 실현할 수 있습니다.

즉, 복잡한 브랜치 전략 대신 단순한 흐름을 따르기 때문에, 팀원 간 협업 속도가 빨라지고 **애자일 팀의 유연성**을 강화합니다.

---

## 3.2 Github Flow 전략의 관점

### 3.2.1 **develop 브랜치와 main 브랜치**

- Git Flow와의 차이점으로 Github Flow에서는 develop 브랜치와 main 브랜치를 엄격히 구분하지 않습니다.
- main 브랜치에 merge하기 전 develop 브랜치에서 배포 준비를 위한 검증 단계를 거칠 수 있지만,
    
    이 과정을 생략하고 develop 브랜치에서 곧바로 main 브랜치로 merge하는 경우도 흔하다.
    

### **3.2.2 release 브랜치**

- Github Flow에서는 release 브랜치가 불필요한 경우가 많으며, 아예 분기하지 않고 바로 배포하는 방식이 일반적입니다.

### 3.2.3 **hotfix 브랜치**

- Github Flow에서는 hotfix를 **작은 기능 변경이나 빠른 수정**으로 간주합니다.
- 따라서 별도의 hotfix 브랜치를 만들지 않고, 바로 수정 후 merge하는 경우가 대부분입니다.